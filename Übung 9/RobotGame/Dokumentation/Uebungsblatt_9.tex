% !TEX program = arara
% arara: pdflatex
% arara: biber
% arara: pdflatex
% arara: pdflatex
\documentclass{pi1}
\begin{document}
% \maketitle	{Nummer}{Abgabedatum}{Tutor1-Name}{Tutor2-Name}{Gruppennummer}
%          		{Teilnehmer 1}{Teilnehmer 2}{Teilnehmer 3}
\maketitle{9}{06.01.2013}{Berghöfer/Senger}{8}
		{Beate Ruffer}{Mohamadreza Khostevan}{Leopold Schulz-Hanke}
% Beginn des eigentlichen Textes

\section{Java-Krise (30\%)}

\emph{If-else} dient der bedingten Anweisung, also der Ausführung einer Anweisung unter einer bestimmten Bedingung (\emph{if}). Die Bedingung ist dabei ein Ausdruck der als Ergebnis einen booleschen Wert (\emph{true} oder \emph{false}) liefern muss. Trifft die Bedingung nicht zu, wird eine alternative Anweisung ausgeführt (\emph{else}). Der Anweisungskörper wird hierbei nur \emph{ein Mal} ausgeführt.

Nehmen wir als Beispiel diese if-Verzweigung:

\begin{lstlisting}[caption={}, firstnumber=1, language=Java]
    public boolean thisIsTrue = true;
    public void ifCheckIf(){
        if (thisIsTrue){
            System.out.println("Something");
        }
        else {
            System.out.println("Something ELSE");
        }
    }
\end{lstlisting}

Ist die Bedingung wahr, (also \emph{thisIsTrue = true}) wird die Anweisung des \emph{if}-Blocks ausgeführt, ist die Bedingung falsch (\emph{thisIsTrue = false}), wird die Anweisung des \emph{else}-Teils ausgeführt.

Möchten wir dies nun als \emph{while Schleife} implementieren, müssen wir darauf achten, dass der Anweisungskörper ebenfalls nur einmal durchgeführt wird. Wir implementieren also gleich beim ersten Durchlauf die Abbruchbedingung. Die boolsche Variable i wird vor jeder Bedingungsprüfung auf true gesetzt und im Anweisungskörper sofort wieder auf false.

Im Beispiel:

\begin{lstlisting}[caption={}, firstnumber=1, language=Java]
public void ifCheckWhile(){
        // if Zweig
        boolean i = true;
        while (i && thisIsTrue){
            System.out.println("Something");
            i = false;
        }
        // else Zweig
        i=true;
        while (i && !thisIsTrue){
            System.out.println("Something ELSE");
            i=false;
        }
    }
\end{lstlisting}

If lässt sich somit ohne großen Aufwand durch while ersetzen.\\
Andersrum ist das etwas schwieriger und kann nicht ohne Einschränkungen umgesetzt werden. Eine If Anweisung kann immer nur genau \texttt{ein Mal} ausgeführt werden. Möchten wir damit eine while Schleife ersetzen, müssen wir einen Weg finden, die if-Anweisung mehrmals (so lange die Bedingung wahr ist) auszuführen.

Versuchen wir die folgende while Schleife nur mit Hilfe von if zu implementieren.

\begin{lstlisting}[caption={}, firstnumber=1, language=Java]
 public void whileCheckWhile(){
        int i = 0;
        while(i < 10){
            System.out.println(i);
            i++;
        }
    }
\end{lstlisting}

Der Wert von i wird also so lange ausgegeben, bis die Bedingung \emph{i $<$ 10} nicht mehr wahr ist.

Da sowohl \emph{while} als auch \emph{if-else} von der Wahrheit einer Bedingung abhängen, ist es theoretisch möglich while durch if zu ersetzen. Um aber die wiederholte Bedingungsprüfung und Ausführung des Schleifenkörpers mit if zu erzwingen, müssen wir eine Methode schreiben, welche sich selbst rekursiv aufruft.

\begin{lstlisting}[caption={}, firstnumber=1, language=Java]
// Es muss whileChekIf(0) ausgeführt werden
    public void whileCheckIf(int i){
        if (i < 10){
            System.out.println(i);
            whileCheckIf(i+1);
        }
    }
\end{lstlisting}

Führt man nun \emph{whileCheckIf(0)} auf, werden genau wie bei der while Schleife alle Zahlen von 0 bis 9 Ausgegeben.

Hieraus ist ersichtlich, dass sich eine bedingte \emph{if-else}-Anweisung durchaus durch mehrere \emph{while}-Schleifen ersetzen lässt. Es muss lediglich, um eine unendliche Wiederholung der Schleife zu vermeiden entweder der zu prüfende Ausdruck (unpraktisch) oder ein zusätzlich eingeführter Parameter (wie im Beispiel) verändert werden, damit die Bedingung zur Ausführung nicht mehr wahr ist. Auch weitere Verzweigungen sollten sich theoretisch so darstellen lassen, wenngleich dies wahrscheinlich schnell relativ unübersichtlich würde.


\section{Delegationsspiel}

\subsection{Vorbereiten (15\%)}

Die Klasse Item hat nun 2 Methoden bekommen, mit denen die Items selbst über ihr Verhalten bestimmen können.
\begin{lstlisting}[caption={Klasse \emph{Item}}, firstnumber=1, language=Java]
import greenfoot.*; // (World, Actor, GreenfootImage, Greenfoot und MouseInfo)

/**
 * Ein Objekt, das aufgehoben werden kann. (Übungsblatt 8)
 * 
 * @author Thomas Röfer
 * @version 02.12.2012
 */
public abstract class Item extends Actor
{
    /**
     * Standrad Methode um das Item zu nutzen, wenn das Item diese Methode nicht überschreibt
     * @param robot Unser Roboter
     * @return Das Item, welches das im Inventar liegende Item ersetzt
     */
    public Item useItem(Robot robot){
        if (robot.collidesWith(Obstacle.class)){
            Obstacle obstacle = (Obstacle) robot.getCollidingObject(Obstacle.class);
            if (matches(obstacle)){
                robot.getWorld().removeObject(obstacle);
                return null;
            }
        }
        return this;
    }
    
    /**
     * Abstrakte Methode, die prüft ob das Item zum Hinderniss passt.
     * @param obstacle Das zu prüfende Hinderniss
     * @return true, wenn das Item zum Hinderniss passt
     */
    public abstract boolean matches(Obstacle obstacle);
}

\end{lstlisting}

Wir möchten im Inventar die Nutzung des Items anstoßen, ohne uns darum kümmern zu müssen, um welches Item es geht.
Wir werden zu keiner Zeit Instanzen von Item direkt erzeugen, daher können wir abstrakte Methoden implementieren, die dann in den Subklassen überschrieben werden. Die Methode \texttt{matches()} ist abstrakt, da wir diese auf jeden Fall in den Subklassen überschreiben müssen, denn nur die Subklasse kann wissen welches Hindernis zu diesem Item passt.\\
\texttt{useItem()} wurde nicht abstrakt implementiert, damit wir auf diese Weise ein Standardverhalten für Items haben. Wenn diese Methode also nicht überschrieben wird, kann man mit dem Item das passende Hindernis überwinden, es wird jedoch weder ein Sound abgespielt noch werden Punkte gutgeschrieben.

\subsection{Delegieren (25\%)}

Jede Subklasse von Item kann nun sein eigenes Verhalten definieren, indem sie \texttt{useItem(Robot robot)} überschreibt. Tut sie dies nicht, wird das Standardverhalten genutzt.\\
Mit der Methode \texttt{matches(Obstacle obstacle)} definieren wir welches Hindernis zum Item passt.

\begin{lstlisting}[caption={Klasse \emph{Key}}, firstnumber=1, language=Java]
/**
 * Ein Schlüssel. Kann benutzt werden, um Türen zu öffnen. (Übungsblatt 3)
 * 
 * @author Thomas Röfer 
 * @version 01.11.2012
 */
public class Key extends Item
{
    /**
     * Methode um das Item zu nutzen
     * @param robot Unser Roboter
     * @return Das Item, welches das im Inventar liegende Item ersetzt
     */
    public Item useItem(Robot robot){
        if (robot.collidesWith(Obstacle.class)){
            Obstacle obstacle = (Obstacle) robot.getCollidingObject(Obstacle.class);
            if (matches(obstacle)){
                robot.getWorld().removeObject(obstacle);
                robot.getScore().setScore(robot.getScore().getScore() + 100);
                Greenfoot.playSound("door-open.wav");
                return null;
            }
        }
        return this;
    }
    
    /**
     * Methode, die prüft ob das Item zum Hinderniss passt.
     * @param obstacle Das zu prüfende Hinderniss
     * @return true, wenn das Item zum Hinderniss passt
     */
    public boolean matches(Obstacle obstacle){   
        return obstacle instanceof Door;
    }
}
\end{lstlisting}

Wir können nun die Methoden blowUpWall() und openDoor() aus der Klasse Robot entfernen. Stattdessen führen wir in jedem act() Zyklus \texttt{inventory.useInventory(this);} aus.
\\
Falls ein Item im Inventar ist, wird das Item nun genutzt.

\begin{lstlisting}[caption={Klasse \emph{Inventory}, Methode \emph{useInventory}}, firstnumber=67, language=Java]
/**
     * Benutzt das im Inventar leigende Item und ersetzt gegebenfalls das Item
     * @param robot Der Roboter wird übergeben.
     */
    public void useInventory(Robot robot){
        if (!isEmpty()){
            Item item = contents.useItem(robot);
            if (item != null){
                store(item);
            } else {
                clear();
            }
        }
    }
\end{lstlisting}

Das zurückgelieferte Item wird wieder im Inventar gespeichert. Standardverhalten - wenn das Item nicht genutzt werden kann - ist, dass sich das Item selbst zurückliefert.\\
Nach der Benutzung wird \texttt{null} zurückgeliefert. In diesem Fall wird das Inventar geleert.\\
\\
Wir haben nun also 2 Varianten implementiert: Rückgabe des Items selbst und Rückgabe von null. Als dritte Variante sollen wir nun ein anderes Item zurückgeben (z.B. Durch Kombination von Item und Hindernis).\\
Dazu haben wir nun zusätzlich zu dem Item Bomb ein weiteres Item \texttt{BombFire} und ein weiteres Hindernis \texttt{Fire}.\\
Um eine Wand sprengen zu können, benötigen wir nun nicht einfach eine Bombe, sondern müssen diese vorher anzünden indem wir (mit der Bombe im Inventar) mit dem Feuer kollidieren. Dann wird die Bombe im Inventar durch die brennende Bombe (BombFire) ersetzt.

\begin{lstlisting}[caption={Klasse \emph{Bomb}, Methode \emph{useItem()}},firstnumber=11, language=Java]
/**
     * Methode um das Item zu nutzen
     * @param robot Unser Roboter
     * @return Das Item, welches das im Inventar liegende Item ersetzt
     */
    public Item useItem(Robot robot){
        if (robot.collidesWith(Obstacle.class)){
            Obstacle obstacle = (Obstacle) robot.getCollidingObject(Obstacle.class);
            if (matches(obstacle)){
                robot.getWorld().removeObject(obstacle);
                Greenfoot.playSound("Bottle.aiff");
                return new BombFire();
            }
        }
        return this;
    }
\end{lstlisting}

\paragraph{Testen} Durch die Änderungen wurde das Verhalten mit dem Schlüssel nicht beeinflusst. Nimmt man diesen ins Inventar auf, kann man nach wie vor keine Wand sprengen. Die korrekte Punkteanzahl wird gutgeschrieben ebenso auch der richtige Sound abgespielt. Mit der Bombe im Inventar können nun keine Wände mehr gesprengt werden. Kollidiert man aber nun mit dem Feuer, wird dieses aus der Welt entfernt und die Bombe im Inventar wird durch die brennende Bombe ersetzt. Damit lassen sich nun die Wände sprengen (Sound korrekt, Punkte korrekt). Das restliche Verhalten des Spiels bleibt weiterhin unverändert.

\subsection{Reflektieren (10\%)}

Durch die Auslagerung der Logik jedes Items in seine eigene Klasse haben wir die Wartbarkeit um einiges verbessert. Möchten wir das Verhalten eines Items nun ändern, wissen wir genau, dass es in dem Item selbst zu finden ist und müssen nicht mehr die entsprechende Methode in der Klasse Robot suchen. Außerdem hat sich dich die Übersichtlichkeit der Klasse Robot dadurch stark verbessert.\\
Wenn wir unser Spiel nun erweitern möchten (wie wir es z.B. mit der brennenden Bombe gemacht haben), müssen wir nur noch eine Subklasse von Item erzeugen und dessen Logik darin implementieren. Es können auch ohne viel Aufwand nun Items mit Standardverhalten hinzugefügt werden, es muss lediglich die Methode \texttt{matches()} überschrieben werden.\\
Es wäre ratsam auf gleiche Weise das Verhalten des Smileys und des Totenkopfs in sich selbst zu implementieren statt in der Klasse Robot. Das ist aktuell schon mit dem abspielen des Tons so definiert, doch auch der Punktewert (bei Smiley) und das starten des replays (Skull) sollten dort definiert sein. Gäbe es eine Superklasse dieser beiden, könnte man ein Standardverhalten für weitere Objekte festlegen, mit denen man Punkte sammelt.

\section{Buh! (20\%)}

\section{Bonusaufgabe: Was war das für ein Geräusch? (5\%)}





\end{document}

